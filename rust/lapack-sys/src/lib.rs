//! Low-level FFI bindings to LAPACK
//!
//! This crate provides raw FFI bindings to LAPACK functions through the LAPACKE
//! C interface. These bindings are unsafe and require manual memory management.
//! Most users should use the higher-level `lapack` crate instead.
//!
//! # Safety
//!
//! All functions in this crate are unsafe as they:
//! - Accept raw pointers
//! - Require correct array dimensions
//! - May use either row-major or column-major layout (LAPACKE supports both)
//! - Do not validate input parameters
//!
//! # Features
//!
//! The following feature flags control which bindings are included:
//! - `linear-systems`: Linear equation solvers (GESV, POSV, etc.)
//! - `least-squares`: Least squares solvers
//! - `eigenvalues`: Eigenvalue and eigenvector computation
//! - `svd`: Singular Value Decomposition
//! - `factorization`: Matrix factorizations (LU, QR, Cholesky, etc.)

#![cfg_attr(not(feature = "std"), no_std)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]

// When in no_std mode, we need to provide some aliases
#[cfg(not(feature = "std"))]
extern crate core as std;

// Define lapack_int type based on whether ILP64 is enabled
// This matches the logic in lapacke_config.h
#[cfg(feature = "ilp64")]
pub type lapack_int = i64;

#[cfg(not(feature = "ilp64"))]
pub type lapack_int = i32;

// Include the bindings generated by bindgen
include!(concat!(env!("OUT_DIR"), "/bindings.rs"));

// Complex number types will be defined by bindgen from the headers
// The exact definitions depend on the LAPACK configuration

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_types_exist() {
        // This test verifies that bindgen successfully generated the basic types
        let _test_int: lapack_int = 0;
        
        // Verify that key constants are defined
        let _row_major = LAPACK_ROW_MAJOR;
        let _col_major = LAPACK_COL_MAJOR;
    }
}